@inject IApplicationState appState
@inject IDataContext data

<div class="card shadow mt-2">
    <div class="card-header">
        <span><b>Work Items</b> with conflicts</span>
        <span class="text-end" style="float: right;">Project #<b>@data.ProjectId</b></span>
    </div>

    <div class="card-body">

        <table class="table table-sm mt-2">
            <tbody>
                @{
                    int itemIndex = 0;
                    int visibleItems = 0;
                    foreach (var e in appState.Conflicts.Items)
                    {
                        int localRowNo = itemIndex;
                        if (itemIndex >= startAt && e.CandidatesLeft > 0)
                        {
                            visibleItems++;
                            TextConflict tc = e;
                            <tr class="align-middle">
                                <td class="text-end @CssRowClass(tc)">@(itemIndex + 1).</td>
                                <td class="text-truncate twa-long-text @CssRowClass(tc)">@e.SrcText</td>
                                @if (ShowNumbers)
                                {
                                    <td class="text-end text-muted small @CssRowClass(tc)">@e.WorkId</td>
                                }
                                <td class="text-end @CssRowClass(tc)">
                                    <button class="btn btn-sm btn-primary" @onclick="@(() => PickRow(tc))"><i class="bi bi-eye" /></button>
                                </td>
                            </tr>
                        }
                        itemIndex++;
                        if (visibleItems >= batchSize)
                            break;
                    }
                }
            </tbody>
        </table>
    </div>
    <div class="card-footer">
        <div class="btn-group w-100">
            <button class="btn btn-sm btn-outline-primary" @onclick="@(() => MoveLeft())"><i class="bi bi-chevron-left" /></button>
            @{
                int i = firstButton;
                int lastButton = firstButton + maxButtons;
                while (i < lastButton)
                {
                    int buttonNumber = i;
                    <button class="btn btn-sm btn-outline-primary" @onclick="@(() => OnBatchPicked(buttonNumber))">@(buttonNumber + 1)</button>
                    i++;
                }
            }
            <button class="btn btn-sm btn-outline-primary" @onclick="@(() => MoveRight())"><i class="bi bi-chevron-right" /></button>
        </div>
    </div>
</div>

@code {

    #region Parameters

    [Parameter]
    public bool ShowNumbers { get; set; } = true;
    [Parameter]
    public EventCallback<TextConflict> OnPick { get; set; }
    [Parameter]
    public TextConflict? SelectedConflict { get; set; }
    #endregion

    #region Local Fields

    private int batchSize = 5;
    private int maxButtons { get; set; }
    private int firstButton = 0;
    private int currentBatchNo = 0;
    private int startAt => currentBatchNo * batchSize;

    #endregion

    private void UpdateButtons()
    {
        maxButtons = Math.Min(appState.Conflicts.Items.Count / batchSize + 1, 15);
    }

    private string CssRowClass(TextConflict conflict)
    {
        if (SelectedConflict != null && conflict.RowKey == SelectedConflict.RowKey)
            return "bg-primary-subtle";
        else
            return "";
    }

    private async Task PickRow(TextConflict pickedRow)
    {
        SelectedConflict = pickedRow;
        await OnPick.InvokeAsync(pickedRow);
    }

    private void OnBatchPicked(int batchNo)
    {
        currentBatchNo = batchNo;
        UpdateButtons();
        StateHasChanged();
    }

    private void MoveLeft()
    {
        if (firstButton > 0)
            firstButton--;
        UpdateButtons();
        StateHasChanged();
    }

    private void MoveRight()
    {
        if (firstButton + 1 < maxButtons)
            firstButton++;
        UpdateButtons();
        StateHasChanged();
    }

}
